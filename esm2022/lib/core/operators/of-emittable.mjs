import { getActionTypeFromInstance } from '@ngxs/store';
import { filter, map } from 'rxjs/operators';
import { getReceiverMetadata } from '../utils';
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
/**
 * `getReceiverTypes([CounterState.increment, CounterState.decrement])`
 * will return a hashmap => `{ 'CounterState.increment': true, 'CounterState.decrement': true }`
 */
function getReceiverTypes(receivers) {
    const types = {};
    for (const receiver of receivers) {
        if (NG_DEV_MODE && typeof receiver !== 'function') {
            throw new TypeError(`Receiver should be a function, got ${receiver}`);
        }
        const metadata = getReceiverMetadata(receiver);
        if (NG_DEV_MODE && (metadata == null || metadata.type == null)) {
            throw new Error(`${receiver.name} should be decorated with @Receiver() decorator`);
        }
        types[metadata.type] = true;
    }
    return types;
}
export function ofEmittableDispatched(...receivers) {
    return ofEmittable(getReceiverTypes(receivers), "DISPATCHED" /* ActionStatus.Dispatched */);
}
export function ofEmittableSuccessful(...receivers) {
    return ofEmittable(getReceiverTypes(receivers), "SUCCESSFUL" /* ActionStatus.Successful */);
}
export function ofEmittableCanceled(...receivers) {
    return ofEmittable(getReceiverTypes(receivers), "CANCELED" /* ActionStatus.Canceled */);
}
export function ofEmittableErrored(...receivers) {
    return ofEmittable(getReceiverTypes(receivers), "ERRORED" /* ActionStatus.Errored */);
}
export function ofEmittable(types, status) {
    return source => source.pipe(filter((ctx) => {
        const type = getActionTypeFromInstance(ctx.action);
        const hashMapHasType = !!types[type];
        const contextHasTransmittedStatus = ctx.status === status;
        return hashMapHasType && contextHasTransmittedStatus;
    }), map(({ action, error }) => ({
        error,
        type: getActionTypeFromInstance(action),
        payload: action.payload
    })));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2YtZW1pdHRhYmxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9lbWl0dGVyL3NyYy9saWIvY29yZS9vcGVyYXRvcnMvb2YtZW1pdHRhYmxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUd4RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBUTdDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUkvQyxNQUFNLFdBQVcsR0FBRyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO0FBRWxFOzs7R0FHRztBQUNILFNBQVMsZ0JBQWdCLENBQUMsU0FBcUI7SUFDN0MsTUFBTSxLQUFLLEdBQVUsRUFBRSxDQUFDO0lBRXhCLEtBQUssTUFBTSxRQUFRLElBQUksU0FBUyxFQUFFLENBQUM7UUFDakMsSUFBSSxXQUFXLElBQUksT0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDbEQsTUFBTSxJQUFJLFNBQVMsQ0FBQyxzQ0FBc0MsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUN4RSxDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFL0MsSUFBSSxXQUFXLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxJQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUMvRCxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksaURBQWlELENBQUMsQ0FBQztRQUNyRixDQUFDO1FBRUQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDOUIsQ0FBQztJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVELE1BQU0sVUFBVSxxQkFBcUIsQ0FDbkMsR0FBRyxTQUFxQjtJQUV4QixPQUFPLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsNkNBQTBCLENBQUM7QUFDM0UsQ0FBQztBQUVELE1BQU0sVUFBVSxxQkFBcUIsQ0FDbkMsR0FBRyxTQUFxQjtJQUV4QixPQUFPLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsNkNBQTBCLENBQUM7QUFDM0UsQ0FBQztBQUVELE1BQU0sVUFBVSxtQkFBbUIsQ0FDakMsR0FBRyxTQUFxQjtJQUV4QixPQUFPLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMseUNBQXdCLENBQUM7QUFDekUsQ0FBQztBQUVELE1BQU0sVUFBVSxrQkFBa0IsQ0FDaEMsR0FBRyxTQUFxQjtJQUV4QixPQUFPLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsdUNBQXVCLENBQUM7QUFDeEUsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQ3pCLEtBQVksRUFDWixNQUFvQjtJQUVwQixPQUFPLE1BQU0sQ0FBQyxFQUFFLENBQ2QsTUFBTSxDQUFDLElBQUksQ0FDVCxNQUFNLENBQUMsQ0FBQyxHQUFrQixFQUFFLEVBQUU7UUFDNUIsTUFBTSxJQUFJLEdBQUcseUJBQXlCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBRSxDQUFDO1FBQ3BELE1BQU0sY0FBYyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckMsTUFBTSwyQkFBMkIsR0FBRyxHQUFHLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQztRQUMxRCxPQUFPLGNBQWMsSUFBSSwyQkFBMkIsQ0FBQztJQUN2RCxDQUFDLENBQUMsRUFDRixHQUFHLENBQ0QsQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQWlCLEVBQUUsRUFBRSxDQUNuQyxDQUEwQjtRQUN4QixLQUFLO1FBQ0wsSUFBSSxFQUFFLHlCQUF5QixDQUFDLE1BQU0sQ0FBQztRQUN2QyxPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87S0FDeEIsQ0FBQSxDQUNKLENBQ0YsQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlIH0gZnJvbSAnQG5neHMvc3RvcmUnO1xuXG5pbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtcbiAgQWN0aW9uU3RhdHVzLFxuICBBY3Rpb25Db250ZXh0LFxuICBPZkVtaXR0YWJsZUFjdGlvbkNvbnRleHQsXG4gIFR5cGVzXG59IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XG5pbXBvcnQgeyBnZXRSZWNlaXZlck1ldGFkYXRhIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGU7XG5cbi8qKlxuICogYGdldFJlY2VpdmVyVHlwZXMoW0NvdW50ZXJTdGF0ZS5pbmNyZW1lbnQsIENvdW50ZXJTdGF0ZS5kZWNyZW1lbnRdKWBcbiAqIHdpbGwgcmV0dXJuIGEgaGFzaG1hcCA9PiBgeyAnQ291bnRlclN0YXRlLmluY3JlbWVudCc6IHRydWUsICdDb3VudGVyU3RhdGUuZGVjcmVtZW50JzogdHJ1ZSB9YFxuICovXG5mdW5jdGlvbiBnZXRSZWNlaXZlclR5cGVzKHJlY2VpdmVyczogRnVuY3Rpb25bXSk6IFR5cGVzIHtcbiAgY29uc3QgdHlwZXM6IFR5cGVzID0ge307XG5cbiAgZm9yIChjb25zdCByZWNlaXZlciBvZiByZWNlaXZlcnMpIHtcbiAgICBpZiAoTkdfREVWX01PREUgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWNlaXZlciBzaG91bGQgYmUgYSBmdW5jdGlvbiwgZ290ICR7cmVjZWl2ZXJ9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YWRhdGEgPSBnZXRSZWNlaXZlck1ldGFkYXRhKHJlY2VpdmVyKTtcblxuICAgIGlmIChOR19ERVZfTU9ERSAmJiAobWV0YWRhdGEgPT0gbnVsbCB8fCBtZXRhZGF0YS50eXBlID09IG51bGwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVjZWl2ZXIubmFtZX0gc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoIEBSZWNlaXZlcigpIGRlY29yYXRvcmApO1xuICAgIH1cblxuICAgIHR5cGVzW21ldGFkYXRhLnR5cGVdID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9mRW1pdHRhYmxlRGlzcGF0Y2hlZChcbiAgLi4ucmVjZWl2ZXJzOiBGdW5jdGlvbltdXG4pOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgT2ZFbWl0dGFibGVBY3Rpb25Db250ZXh0PGFueT4+IHtcbiAgcmV0dXJuIG9mRW1pdHRhYmxlKGdldFJlY2VpdmVyVHlwZXMocmVjZWl2ZXJzKSwgQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZFbWl0dGFibGVTdWNjZXNzZnVsKFxuICAuLi5yZWNlaXZlcnM6IEZ1bmN0aW9uW11cbik6IE9wZXJhdG9yRnVuY3Rpb248YW55LCBPZkVtaXR0YWJsZUFjdGlvbkNvbnRleHQ8YW55Pj4ge1xuICByZXR1cm4gb2ZFbWl0dGFibGUoZ2V0UmVjZWl2ZXJUeXBlcyhyZWNlaXZlcnMpLCBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvZkVtaXR0YWJsZUNhbmNlbGVkKFxuICAuLi5yZWNlaXZlcnM6IEZ1bmN0aW9uW11cbik6IE9wZXJhdG9yRnVuY3Rpb248YW55LCBPZkVtaXR0YWJsZUFjdGlvbkNvbnRleHQ8YW55Pj4ge1xuICByZXR1cm4gb2ZFbWl0dGFibGUoZ2V0UmVjZWl2ZXJUeXBlcyhyZWNlaXZlcnMpLCBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZFbWl0dGFibGVFcnJvcmVkKFxuICAuLi5yZWNlaXZlcnM6IEZ1bmN0aW9uW11cbik6IE9wZXJhdG9yRnVuY3Rpb248YW55LCBPZkVtaXR0YWJsZUFjdGlvbkNvbnRleHQ8YW55Pj4ge1xuICByZXR1cm4gb2ZFbWl0dGFibGUoZ2V0UmVjZWl2ZXJUeXBlcyhyZWNlaXZlcnMpLCBBY3Rpb25TdGF0dXMuRXJyb3JlZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvZkVtaXR0YWJsZShcbiAgdHlwZXM6IFR5cGVzLFxuICBzdGF0dXM6IEFjdGlvblN0YXR1c1xuKTogT3BlcmF0b3JGdW5jdGlvbjxhbnksIE9mRW1pdHRhYmxlQWN0aW9uQ29udGV4dDxhbnk+PiB7XG4gIHJldHVybiBzb3VyY2UgPT5cbiAgICBzb3VyY2UucGlwZShcbiAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGN0eC5hY3Rpb24pITtcbiAgICAgICAgY29uc3QgaGFzaE1hcEhhc1R5cGUgPSAhIXR5cGVzW3R5cGVdO1xuICAgICAgICBjb25zdCBjb250ZXh0SGFzVHJhbnNtaXR0ZWRTdGF0dXMgPSBjdHguc3RhdHVzID09PSBzdGF0dXM7XG4gICAgICAgIHJldHVybiBoYXNoTWFwSGFzVHlwZSAmJiBjb250ZXh0SGFzVHJhbnNtaXR0ZWRTdGF0dXM7XG4gICAgICB9KSxcbiAgICAgIG1hcChcbiAgICAgICAgKHsgYWN0aW9uLCBlcnJvciB9OiBBY3Rpb25Db250ZXh0KSA9PlxuICAgICAgICAgIDxPZkVtaXR0YWJsZUFjdGlvbkNvbnRleHQ+e1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICB0eXBlOiBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbiksXG4gICAgICAgICAgICBwYXlsb2FkOiBhY3Rpb24ucGF5bG9hZFxuICAgICAgICAgIH1cbiAgICAgIClcbiAgICApO1xufVxuIl19